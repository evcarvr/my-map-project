<!DOCTYPE html>
<html>
<head>
  <title>Marathon Walking Route with Rotation & Alerts</title>
  <style>
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; background: #f8f8f8; }
    #map { height: 100vh; width: 100%; }
    #controls { 
      position: absolute; top: 10px; left: 10px; z-index: 5; 
      background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      width: 160px;
    }
    #controls button, input { margin: 6px 0; width: 100%; font-weight: bold; }
    #progressBarWrapper {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 280px;
      background: #800000;
      border-radius: 6px;
      padding: 8px 12px;
      box-shadow: 0 2px 6px rgb(255, 252, 252);
      font-family: sans-serif;
      z-index: 10;
      color: white;
      font-weight: bold;
      user-select: none;
    }
    #progressOuter {
      width: 100%; height: 10px; background: rgb(255, 255, 255); 
      border-radius: 5px; overflow: hidden; margin-top: 6px;
    }
    #progressInner {
      width: 0%; height: 100%; background: #00c853; transition: width .2s linear;
    }
    .muted { color:#ccc; font-size: 12px; font-weight: normal; }

    /* Popup styles */
    #popup {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px 28px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      z-index: 20;
      display: none;
      font-weight: bold;
      font-size: 18px;
      text-align: center;
      max-width: 90%;
      user-select: none;
    }
    #popup button {
      margin-top: 18px;
      padding: 8px 18px;
      font-size: 16px;
      cursor: pointer;
      font-weight: bold;
      background-color: #1A73E8;
      color: white;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    #popup button:hover {
      background-color: #0b5394;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="clearRoute()">Clear Route</button>
    <button onclick="savePath()">Save Path</button>
    <button onclick="loadSavedPath()">Load Saved Path</button>
    <button onclick="generateShareLink()">Generate Share Link</button>
    <button id="startNavBtn" disabled onclick="startNavigation()">Start Navigation</button>
    <input type="text" id="shareLink" readonly onclick="this.select()" placeholder="Share link will appear here">
  </div>

  <div id="progressBarWrapper" style="display:none">
    <div id="progressText">0% â€¢ 0 m left</div>
    <div id="progressOuter">
      <div id="progressInner"></div>
    </div>
    <div class="muted" id="etaText"></div>
  </div>

  <div id="popup">
    <div id="popupMessage"></div>
    <button onclick="closePopup()">Close</button>
  </div>

  <div id="map"></div>

  <!-- Google Maps + Geometry + Roads API -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDgUtO-QtZfRHq1mARfb3U-G_FNCM_ySN8&libraries=geometry&callback=initMap" async defer></script>

  <script>
    let map, directionsService, directionsRenderer;
    let waypoints = [];
    let waypointMarkers = [];
    let fullPath = [];
    let cumDist = [];
    let totalDist = 0;
    let upcomingRoute, upcomingRouteBase, doneRoute, doneRouteBase;
    let startMarker, endMarker;

    let gpsMarker = null;
    let navigationStarted = false;
    let lastProgressIndex = 0;
    let lastProgressTime = null;
    let lastProgressMeters = 0;

    let wrongPathTimer = null;
    let wrongPathPopupShown = false;

    // Rotating arrow icon for user marker
    let arrowIcon = {
      path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
      scale: 7,
      rotation: 0,
      fillColor: "#1A73E8",
      fillOpacity: 1,
      strokeWeight: 1,
      strokeColor: "#ffffff"
    };

    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: 12.93, lng: 77.61 },
        zoom: 17,
        tilt: 45,
        heading: 0,
        streetViewControl: false,
        mapTypeControl: false,
        gestureHandling: "greedy",
        rotateControl: true,
      });

      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        preserveViewport: true,
        polylineOptions: { strokeOpacity: 0 }
      });

      upcomingRouteBase = new google.maps.Polyline({
        map,
        strokeColor: "#0b5394",
        strokeOpacity: 0.4,
        strokeWeight: 12,
      });
      doneRouteBase = new google.maps.Polyline({
        map,
        strokeColor: "#777",
        strokeOpacity: 0.4,
        strokeWeight: 12,
      });

      upcomingRoute = new google.maps.Polyline({
        map,
        strokeColor: "#1A73E8",
        strokeOpacity: 1,
        strokeWeight: 6,
      });
      doneRoute = new google.maps.Polyline({
        map,
        strokeColor: "#9e9e9e",
        strokeOpacity: 1,
        strokeWeight: 6,
      });

      map.addListener("click", e => addWaypoint(e.latLng));

      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          onPositionUpdate,
          err => console.error("Geolocation error", err),
          { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
        );
      }

      loadPointsFromURL();
    }

    // Snap user clicks to nearest road using Roads API
    function snapToRoad(lat, lng, callback) {
      const url = `https://roads.googleapis.com/v1/nearestRoads?points=${lat},${lng}&key=AIzaSyDgUtO-QtZfRHq1mARfb3U-G_FNCM_ySN8`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          if (data.snappedPoints && data.snappedPoints.length > 0) {
            const snapped = data.snappedPoints[0].location;
            callback(new google.maps.LatLng(snapped.latitude, snapped.longitude));
          } else {
            callback(new google.maps.LatLng(lat, lng));
          }
        })
        .catch(() => callback(new google.maps.LatLng(lat, lng)));
    }

    function addWaypoint(latlng) {
      snapToRoad(latlng.lat(), latlng.lng(), snappedPoint => {
        waypoints.push(snappedPoint);
        const marker = createMarker(snappedPoint, waypoints.length - 1);
        waypointMarkers.push(marker);
        updateRoute();
      });
    }

    function createMarker(latlng, index) {
      const marker = new google.maps.Marker({
        position: latlng,
        map,
        label: `${index + 1}`,
        draggable: true
      });

      marker.addListener("click", () => {
        const idx = waypointMarkers.indexOf(marker);
        if (idx !== -1) deleteWaypoint(idx);
      });

      marker.addListener("dragend", () => {
        const idx = waypointMarkers.indexOf(marker);
        if (idx !== -1) {
          waypoints[idx] = marker.getPosition();
          updateRoute();
        }
      });

      return marker;
    }

    function deleteWaypoint(index) {
      waypointMarkers[index].setMap(null);
      waypointMarkers.splice(index, 1);
      waypoints.splice(index, 1);
      relabelMarkers();
      updateRoute();
    }

    function relabelMarkers() {
      waypointMarkers.forEach((m, i) => m.setLabel(`${i + 1}`));
    }

    function updateRoute() {
      if (waypoints.length < 2) {
        resetPathState();
        resetNavigation();
        return;
      }
      calculateRoute();
    }

    function calculateRoute() {
      const origin = waypoints[0];
      const destination = waypoints[waypoints.length - 1];
      const midpoints = waypoints.slice(1, -1).map(loc => ({ location: loc, stopover: true }));

      const request = {
        origin,
        destination,
        waypoints: midpoints,
        travelMode: google.maps.TravelMode.WALKING,
        provideRouteAlternatives: false
      };

      directionsService.route(request, (result, status) => {
        if (status !== "OK") {
          alert("Directions request failed due to " + status);
          return;
        }

        directionsRenderer.setDirections(result);
        fullPath = result.routes[0].overview_path;

        cumDist = [0];
        for (let i = 1; i < fullPath.length; i++) {
          const d = google.maps.geometry.spherical.computeDistanceBetween(fullPath[i - 1], fullPath[i]);
          cumDist.push(cumDist[i - 1] + d);
        }
        totalDist = cumDist[cumDist.length - 1];

        doneRoute.setPath([]);
        doneRouteBase.setPath([]);
        upcomingRoute.setPath(fullPath);
        upcomingRouteBase.setPath(fullPath);

        addStartEndMarkers();

        lastProgressIndex = 0;
        lastProgressTime = null;
        lastProgressMeters = 0;

        hideProgressBar();
        resetNavigation();
      });
    }

    function addStartEndMarkers() {
      if (startMarker) startMarker.setMap(null);
      if (endMarker) endMarker.setMap(null);

      if (fullPath.length > 0) {
        startMarker = new google.maps.Marker({
          position: fullPath[0],
          map,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#1A73E8",
            fillOpacity: 1,
            strokeColor: "#fff",
            strokeWeight: 3
          }
        });
        endMarker = new google.maps.Marker({
          position: fullPath[fullPath.length - 1],
          map,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#1A73E8",
            fillOpacity: 1,
            strokeColor: "#fff",
            strokeWeight: 3
          }
        });
      }
    }

    function resetPathState() {
      fullPath = [];
      cumDist = [];
      totalDist = 0;
      doneRoute.setPath([]);
      doneRouteBase.setPath([]);
      upcomingRoute.setPath([]);
      upcomingRouteBase.setPath([]);
      if (startMarker) startMarker.setMap(null);
      if (endMarker) endMarker.setMap(null);
      document.getElementById("startNavBtn").disabled = true;
    }

    function resetNavigation() {
      navigationStarted = false;
      lastProgressIndex = 0;
      lastProgressTime = null;
      lastProgressMeters = 0;
      hideProgressBar();
      hidePopup();
      if (wrongPathTimer) {
        clearTimeout(wrongPathTimer);
        wrongPathTimer = null;
      }
      wrongPathPopupShown = false;
      document.getElementById("startNavBtn").disabled = false;
    }

    // Geolocation update handler
    function onPositionUpdate(pos) {
      const currentPos = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
      const headingDegrees = pos.coords.heading !== null && !isNaN(pos.coords.heading) ? pos.coords.heading : 0;

      if (!gpsMarker) {
        gpsMarker = new google.maps.Marker({
          position: currentPos,
          map,
          zIndex: 999,
          icon: Object.assign({}, arrowIcon, { rotation: headingDegrees })
        });
      } else {
        gpsMarker.setPosition(currentPos);
        arrowIcon.rotation = headingDegrees;
        gpsMarker.setIcon(arrowIcon);
      }

      // Rotate map on desktop (only if tilt 45 for 3D)
      if (map.getTilt() === 45) {
        map.setHeading(headingDegrees);
      }

      if (!navigationStarted) {
        checkStartButton(currentPos);
      } else {
        updateSmoothProgress(currentPos);
      }
    }

    function checkStartButton(currentPos) {
      const btn = document.getElementById("startNavBtn");
      if (waypoints.length === 0) { btn.disabled = true; return; }
      const start = waypoints[0];
      const dist = google.maps.geometry.spherical.computeDistanceBetween(currentPos, start);
      btn.disabled = dist > 30 || fullPath.length === 0;
    }

    function startNavigation() {
      if (!fullPath.length) {
        alert("Create a route first.");
        return;
      }
      navigationStarted = true;
      lastProgressIndex = 0;
      lastProgressTime = Date.now();
      lastProgressMeters = 0;
      doneRoute.setPath([]);
      doneRouteBase.setPath([]);
      upcomingRoute.setPath(fullPath);
      upcomingRouteBase.setPath(fullPath);
      document.getElementById("startNavBtn").disabled = true;
      showProgressBar();
      updateProgressUI(0, totalDist);
      hidePopup();

      if (wrongPathTimer) clearTimeout(wrongPathTimer);
      wrongPathPopupShown = false;
    }

    // Compute user progress on route and update UI
    function updateSmoothProgress(currentPos) {
      if (!fullPath.length) return;

      // Search close segments to project user position
      const searchStart = Math.max(lastProgressIndex - 5, 0);
      let best = { dist: Infinity, segIndex: -1, projPoint: null, t: 0, cumMetersAtProj: 0 };

      for (let i = searchStart; i < fullPath.length - 1; i++) {
        const a = fullPath[i];
        const b = fullPath[i + 1];
        const proj = projectPointOnSegment(currentPos, a, b);
        if (!proj) continue;
        const d = google.maps.geometry.spherical.computeDistanceBetween(currentPos, proj.point);
        if (d < best.dist) {
          best.dist = d;
          best.segIndex = i;
          best.projPoint = proj.point;
          best.t = proj.t;
          const distToA = cumDist[i];
          const segLen = google.maps.geometry.spherical.computeDistanceBetween(a, b);
          best.cumMetersAtProj = distToA + segLen * proj.t;
        }
      }
      if (best.segIndex === -1) return;

      // Show wrong path popup if too far (>25m)
      if (best.dist > 25) {
        showWrongPathPopup();
      } else {
        hidePopup();
        wrongPathPopupShown = false;
        if (wrongPathTimer) {
          clearTimeout(wrongPathTimer);
          wrongPathTimer = null;
        }
      }

      // Update polylines for done and upcoming path
      const donePts = [];
      for (let i = 0; i <= best.segIndex; i++) donePts.push(fullPath[i]);
      donePts.push(best.projPoint);

      const futurePts = [best.projPoint];
      for (let i = best.segIndex + 1; i < fullPath.length; i++) futurePts.push(fullPath[i]);

      doneRoute.setPath(donePts);
      doneRouteBase.setPath(donePts);
      upcomingRoute.setPath(futurePts);
      upcomingRouteBase.setPath(futurePts);

      lastProgressIndex = Math.max(lastProgressIndex, best.segIndex);

      const doneMeters = best.cumMetersAtProj;
      const remain = Math.max(0, totalDist - doneMeters);
      const pct = totalDist > 0 ? (doneMeters / totalDist) * 100 : 0;
      updateProgressUI(pct, remain);

      // Arrival popup if within 15m of destination
      if (remain < 15) {
        showArrivalPopup();
        resetNavigation();
      }
    }

    function projectPointOnSegment(p, a, b) {
      // Projects point p on line segment a-b in lat/lng space
      const ax = a.lng(), ay = a.lat();
      const bx = b.lng(), by = b.lat();
      const px = p.lng(), py = p.lat();
      const abx = bx - ax;
      const aby = by - ay;
      const apx = px - ax;
      const apy = py - ay;
      const ab2 = abx * abx + aby * aby;
      if (ab2 === 0) return null;
      let t = (apx * abx + apy * aby) / ab2;
      t = Math.max(0, Math.min(1, t));
      const qx = ax + abx * t;
      const qy = ay + aby * t;
      return { point: new google.maps.LatLng(qy, qx), t };
    }

    // UI PROGRESS BAR
    function showProgressBar() { document.getElementById("progressBarWrapper").style.display = "block"; }
    function hideProgressBar() { document.getElementById("progressBarWrapper").style.display = "none"; }

    function updateProgressUI(percent, remainingMeters) {
      const pctRounded = Math.min(100, Math.max(0, percent)).toFixed(1);
      const progText = document.getElementById("progressText");
      const progInner = document.getElementById("progressInner");
      const etaText = document.getElementById("etaText");

      progInner.style.width = pctRounded + "%";
      progText.textContent = `${pctRounded}% â€¢ ${formatDistance(remainingMeters)} left`;

      if (lastProgressTime == null) {
        lastProgressTime = Date.now();
        lastProgressMeters = totalDist - remainingMeters;
        etaText.textContent = "";
      } else {
        const now = Date.now();
        const dt = (now - lastProgressTime) / 1000;
        const dMeters = (totalDist - remainingMeters) - lastProgressMeters;
        if (dMeters > 1 && dt > 1) {
          const speedMps = dMeters / dt;
          if (speedMps > 0.1) {
            const etaSec = remainingMeters / speedMps;
            etaText.textContent = "ETA: " + formatTime(etaSec);
          } else {
            etaText.textContent = "ETA: â€”";
          }
          lastProgressTime = now;
          lastProgressMeters = totalDist - remainingMeters;
        }
      }
    }

    function formatDistance(meters) {
      if (meters >= 1000) {
        return (meters / 1000).toFixed(2) + " km";
      }
      return Math.round(meters) + " m";
    }
    function formatTime(sec) {
      const minutes = Math.floor(sec / 60);
      const seconds = Math.floor(sec % 60);
      return minutes + "m " + seconds + "s";
    }

    // Popup management
    function showPopup(message) {
      const popup = document.getElementById("popup");
      document.getElementById("popupMessage").textContent = message;
      popup.style.display = "block";
    }
    function hidePopup() {
      document.getElementById("popup").style.display = "none";
    }
    function closePopup() {
      hidePopup();
      // Restart timer if popup is for wrong path
      if (wrongPathPopupShown) {
        scheduleWrongPathPopup();
      }
    }

    // Wrong path popup (shown every 5 minutes if user off-route)
    function showWrongPathPopup() {
      if (wrongPathPopupShown) return; // Already showing or scheduled

      showPopup("Your path is wrong. Please follow the route.");
      wrongPathPopupShown = true;

      scheduleWrongPathPopup();
    }
    function scheduleWrongPathPopup() {
      if (wrongPathTimer) clearTimeout(wrongPathTimer);
      // Show again in 5 minutes if user still off route
      wrongPathTimer = setTimeout(() => {
        wrongPathPopupShown = false;
        // Check if still off-route; will re-trigger popup on next update
      }, 5 * 60 * 1000);
    }

    // Arrival popup
    function showArrivalPopup() {
      showPopup("ðŸŽ‰ Yep! You have reached your destination.");
    }

    // Share/save/load functionality
    function savePath() {
      if (waypoints.length < 2) {
        alert("Add at least two waypoints before saving.");
        return;
      }
      const arr = waypoints.map(p => p.lat() + "," + p.lng());
      localStorage.setItem("savedRoute", JSON.stringify(arr));
      alert("Route saved locally.");
    }

    function loadSavedPath() {
      const saved = localStorage.getItem("savedRoute");
      if (!saved) {
        alert("No saved route found.");
        return;
      }
      clearRoute();
      const arr = JSON.parse(saved);
      arr.forEach(str => {
        const [lat, lng] = str.split(",");
        addWaypoint(new google.maps.LatLng(parseFloat(lat), parseFloat(lng)));
      });
    }

    function generateShareLink() {
      if (waypoints.length < 2) {
        alert("Add at least two waypoints before generating share link.");
        return;
      }
      const baseURL = window.location.origin + window.location.pathname;
      const pointsStr = waypoints.map(p => p.lat().toFixed(6) + "," + p.lng().toFixed(6)).join(";");
      const url = `${baseURL}?points=${encodeURIComponent(pointsStr)}`;
      const shareInput = document.getElementById("shareLink");
      shareInput.value = url;
      shareInput.select();
      document.execCommand("copy");
      alert("Share link copied to clipboard.");
    }

    function loadPointsFromURL() {
      const params = new URLSearchParams(window.location.search);
      const pts = params.get("points");
      if (!pts) return;

      const latlngs = pts.split(";").map(s => {
        const [lat, lng] = s.split(",");
        return new google.maps.LatLng(parseFloat(lat), parseFloat(lng));
      });

      latlngs.forEach(p => addWaypoint(p));
    }

    function clearRoute() {
      waypointMarkers.forEach(m => m.setMap(null));
      waypointMarkers = [];
      waypoints = [];
      resetPathState();
      resetNavigation();
      document.getElementById("shareLink").value = "";
    }
  </script>
</body>
</html>
